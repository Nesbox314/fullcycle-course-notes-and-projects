MICROSSERVIÇOS
- São aplicações comuns
- Tem objetivos bem definidos
- Faz parte de um ecosistema
- São independentes/autônomos
- Se comunicam o tempo todo
- Microsserviços vs Monolíticos
    - Microserviços tem objetivos bem definidos, quando monolíticos tem toda a aplicação no mesmo sistema
    - Microsserviços tem várias linguagens de programação, quando monolíticos tem apenas uma
    - Microsserviços tem menos riscos de deploy, quando monolíticos tem mais riscos
    - Microsserviços tem a parte organizacional mais facilitada, enquanto os monolíticos todos trabalham no mesmo sistema
    - Sistemas monolíticos são mais fáceis de iniciar
- Quando eu devo utilizar microserviços
    - Escalar times
    - Contextos bem definidos
    - Quando você tem maturidade nos processos de entrega
    - Quando tenho a necessidade de escalar partes da aplicação
    - Quando eu preciso de tecnologias específicas para partes do meu sistema
- Quando eu devo utilizar sistemas monolíticos
    - Necessidade de provas de conceito
    - Projetos onde não conhecemos todo o domínio
    - Governança simplificada clara sobre tecnologias
    - Facilidade de contratação e treinamento dos devs
    - Tudo está no mesmo lugar
    - Compartilhamento claro de bibliotecas de código
- Migração de monolitos para Microsserviços
    - Separação de Contextos (DDD)
    - Evite o excesso de granularidade
    - Verifique dependências (monolito distribuído)
    - Planeje o processo de migração dos bancos de dados
    - Eventos
    - Não tenha medo de duplicação de dados
    - Consistência eventual
    - CI/DD/Testes/Ambientes
    - Inicie pelas beiradas, comece pelas partes menos impactantes do Ambientes
    - Padrão de estrangulamento
- Componentização
    - In-memory calls
    - Out of process 
    - Auto deployável
    - Ser via serviços
    - Áreas de negócios
        - Separação das equipes com base em módulos de microserviços
    - Produtos e não projetos
        - Uma visão diferente sobre os projetos, vendo-os como produtos pode mudar a qualidade final e o pós implementação
    - Smart endpoints and dumb pipes
        - Tire a complexidade dos caminhos entre os microserviços, e coloque nos endpoints
    - Governança descentralizada
        - Há regras diferenciadas para cada um dos microserviços, permitindo uma liberdade melhor de solução de problemas
    - Dados descentralizados
        - Dados descentralizados garantem uma segurança maior em casos de danos aos servidores, porém geram mais trabalho para sincronização dos dados entre as bases
    - Automação de infraestrutura
        - É extremamente necessário o planejamento da automação, já que são vários Microsserviços
    - Desenhado para falhar
        - Pensar nos planos a, b e c para manter a resiliência do serviço
    - Design evolutivo
        - Serviços pensados para evoluir, sem ter dependências uns dos outros
- Resiliência
    - Em algum momento, todo o sistema vai falhar...
    - O que é resiliência?
        - É um conjunto de estratégias adotadas para adaptação do sistema quando existirem falhas
        - Possibilita minimizar o risco de perda de dados e transações importantes
    - Quais as estratégias?
        - Deve definir mecanismos de autopreservação para garantir a operação com qualidade
        - O sistema não pode ser "egoísta" ao realizar mais requisições em um sistema que está falhando
        - Um sistema lento no ar é muitas vezes pior do que um sistema fora do ar (efeito dominó)
        - Health check
            - Sem sinais vitais, não é possível saber a "saúde" de um sistema
            - Um sistema doente pode se recuperar caso você redirecione as requisições para outro serviço (self-healing)
            - Health check de qualidade (não adianta testar apenas se o serviço está de pé)
                - Passivo: quando o sistema é acessado ele checa a saúde
                - Ativo: outros sistema validam a saúde do sistema
        - Rate Limiting
            - Protege o sistema com base no que ele foi projetado para suportar
            - Preferência programada por tipo de cliente estratégico
        - Circuit Breaker
            - Protege o sistema fazendo com que as requisições sejam barradas caso necessário
            - Circuito fechado é quando as requisições chegam normalmente
            - Circuito aberto é quando as requisições não chegam ao sistema, erro instantêneo ao cliente
            - Circuito meio aberto permite uma quantidade limitada de requisições para verificação se o sistema tem condições de voltar ao ar integralmente
        - API Gateway
            - Garante que as requisições inapropriadas cheguem até o sistema
            - Implementa políticas de Health Check, Rate Limiting e etc.
        - Service Mesh
            - Controla o tráfego de rede 
            - Evita implementações de proteção pelo próprio sistema 
            - mTLS 
            - Circuit breaker, retry, timeout, fault injection, etc.
        - Trabalhe de forma assíncrona
            - Evitar perda de dados (Kafka)
            - Não há perda de dados no envio de uma transação se o servidor estiver fora do ar
            - O servidor pode processar a transação em seu tempo quando estiver online
            - Entender com profundidade o message broker / sistema de stream