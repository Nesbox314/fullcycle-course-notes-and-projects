MICROSSERVIÇOS
- São aplicações comuns
- Tem objetivos bem definidos
- Faz parte de um ecosistema
- São independentes/autônomos
- Se comunicam o tempo todo
- Microsserviços vs Monolíticos
    - Microserviços tem objetivos bem definidos, quando monolíticos tem toda a aplicação no mesmo sistema
    - Microsserviços tem várias linguagens de programação, quando monolíticos tem apenas uma
    - Microsserviços tem menos riscos de deploy, quando monolíticos tem mais riscos
    - Microsserviços tem a parte organizacional mais facilitada, enquanto os monolíticos todos trabalham no mesmo sistema
    - Sistemas monolíticos são mais fáceis de iniciar
- Quando eu devo utilizar microserviços
    - Escalar times
    - Contextos bem definidos
    - Quando você tem maturidade nos processos de entrega
    - Quando tenho a necessidade de escalar partes da aplicação
    - Quando eu preciso de tecnologias específicas para partes do meu sistema
- Quando eu devo utilizar sistemas monolíticos
    - Necessidade de provas de conceito
    - Projetos onde não conhecemos todo o domínio
    - Governança simplificada clara sobre tecnologias
    - Facilidade de contratação e treinamento dos devs
    - Tudo está no mesmo lugar
    - Compartilhamento claro de bibliotecas de código
- Migração de monolitos para Microsserviços
    - Separação de Contextos (DDD)
    - Evite o excesso de granularidade
    - Verifique dependências (monolito distribuído)
    - Planeje o processo de migração dos bancos de dados
    - Eventos
    - Não tenha medo de duplicação de dados
    - Consistência eventual
    - CI/DD/Testes/Ambientes
    - Inicie pelas beiradas, comece pelas partes menos impactantes do Ambientes
    - Padrão de estrangulamento
- Componentização
    - In-memory calls
    - Out of process 
    - Auto deployável
    - Ser via serviços
    - Áreas de negócios
        - Separação das equipes com base em módulos de microserviços
    - Produtos e não projetos
        - Uma visão diferente sobre os projetos, vendo-os como produtos pode mudar a qualidade final e o pós implementação
    - Smart endpoints and dumb pipes
        - Tire a complexidade dos caminhos entre os microserviços, e coloque nos endpoints
    - Governança descentralizada
        - Há regras diferenciadas para cada um dos microserviços, permitindo uma liberdade melhor de solução de problemas
    - Dados descentralizados
        - Dados descentralizados garantem uma segurança maior em casos de danos aos servidores, porém geram mais trabalho para sincronização dos dados entre as bases
    - Automação de infraestrutura
        - É extremamente necessário o planejamento da automação, já que são vários Microsserviços
    - Desenhado para falhar
        - Pensar nos planos a, b e c para manter a resiliência do serviço
    - Design evolutivo
        - Serviços pensados para evoluir, sem ter dependências uns dos outros
- Resiliência
    - Em algum momento, todo o sistema vai falhar...
    - O que é resiliência?
        - É um conjunto de estratégias adotadas para adaptação do sistema quando existirem falhas
        - Possibilita minimizar o risco de perda de dados e transações importantes
    - Quais as estratégias?
        - Deve definir mecanismos de autopreservação para garantir a operação com qualidade
        - O sistema não pode ser "egoísta" ao realizar mais requisições em um sistema que está falhando
        - Um sistema lento no ar é muitas vezes pior do que um sistema fora do ar (efeito dominó)
        - Health check
            - Sem sinais vitais, não é possível saber a "saúde" de um sistema
            - Um sistema doente pode se recuperar caso você redirecione as requisições para outro serviço (self-healing)
            - Health check de qualidade (não adianta testar apenas se o serviço está de pé)
                - Passivo: quando o sistema é acessado ele checa a saúde
                - Ativo: outros sistema validam a saúde do sistema
        - Rate Limiting
            - Protege o sistema com base no que ele foi projetado para suportar
            - Preferência programada por tipo de cliente estratégico
        - Circuit Breaker
            - Protege o sistema fazendo com que as requisições sejam barradas caso necessário
            - Circuito fechado é quando as requisições chegam normalmente
            - Circuito aberto é quando as requisições não chegam ao sistema, erro instantêneo ao cliente
            - Circuito meio aberto permite uma quantidade limitada de requisições para verificação se o sistema tem condições de voltar ao ar integralmente
        - API Gateway
            - Garante que as requisições inapropriadas cheguem até o sistema
            - Implementa políticas de Health Check, Rate Limiting e etc.
        - Service Mesh
            - Controla o tráfego de rede 
            - Evita implementações de proteção pelo próprio sistema 
            - mTLS 
            - Circuit breaker, retry, timeout, fault injection, etc.
        - Trabalhe de forma assíncrona
            - Evitar perda de dados (Kafka)
            - Não há perda de dados no envio de uma transação se o servidor estiver fora do ar
            - O servidor pode processar a transação em seu tempo quando estiver online
            - Entender com profundidade o message broker / sistema de stream
        - Retry
            - É uma forma de não perder a mensagem implementando no sistema um meio de reenvio de mensagens
            - Exponential backoff
                - Tentativas de reenvio com tempo em crescente exponencial
                - Jitter: nova tentativas de modo aleatório, diminuindo a concorrência
        - Garantias de entrega
            - Kafka: message broker que garante a entrega das mensagens
            - Transactional outbox
        - Garantia de recebimento
            - Auto Ack = false e commit manual
            - Prefetch alinhado a volumetria
        - Observabilidade
            - APM
            - Tracing distribúido
            - Métricas personalizadas
            - Spans personalizadas
            - Open telemetry
- API Composition
    - Como resolver um problema de dados compartilhados entre diversas APIs?
        - Juntar os dados no front-end
        - Juntar os dados via Service Composer
        - Juntar via API Gateway
        - Quais problemas podem aparecer?
            - Disponibilidade de algum serviço
            - Problema na consistência dos dados
            - Aumento da complexidade
            - Necessidade de criação de um serviço para uso de serviços
            - Alta latência
            - Trabalhar de forma síncrona
    - E quando houver problema de regras de negócio compartilhadas?
        - Podemos criar um serviço extra para operar as regras de negócio
        - Pode rodar em background
    - RESILIÊNCIA! E se os dados de um lado não vierem? Há de ser criado um plano B
    - Decompose by business capability
        - Separação de um monolito em diversos microserviços através dos módulos da aplicação
        - Domain Driven Desing pode mitigar os problemas advindos dessa separação
    - Strangler application
        - Toda nova feature será desenvolvida em micro-serviço
        - Pegar pequenos pedaços do sistema e transformar em microserviços 
        - Realizar esses procedimentos até o sistema monolítico virar um microsserviços
    - ACL - Camada anti-corrupção
        - Crie camadas para proteger os dados e as integrações de alterações, deixando-as genéricas
        - Pode-se criar um microserviço para proteger essas integrações
- API Gateway
    - É um ponto de entrada para a sua malha de microsserviços
    - É ideal que não exponhamos os microsserviços para redes não internas
    - Possível implementação de várias estratégias para proteção dos microsserviços
    - Implementação de sistema de autenticação global
    - Stateful (tem um banco de dados interno que guarda todas as informações)
    - Stateless (sem banco de dados, apenas um arquivo de manifesto)
- BFF (back-end for front-end)
    - É um conceito relacionado a criar backends que tragam apenas as informações que o front precisa, ganhando performance
    - GraphQL pode driblar esse problema
- Bancos de dados voltados para microsserviços
    - Quando os microsserviços acessam o mesmo banco de dados, há uma facilidade no desenvolvimento, porém no caso de falha no banco, todos os microsserviços vão parar
    - Bancos de dados separados para cada microsserviço, são independentes, porém há necessidade de sincronização de dados
- Consolidação de dados
    - Para juntar dados de vários microsserviços separados, há algumas estratégias
        - Realizar uma requisição para cada microsserviço, e juntar os dados no front-end (custoso e lento)
        - Criar um microsserviço apenas para junção dos dados do relatório
        - Criar um banco de dados com tabelas projetadas, que na entrada dos dados eles já são agrupados
- Transactional outbox
    - Ter uma tabela que armazena as requisições que deram erro é uma boa ideia
    - Criar serviços para consumir as tabelas com requisições errados
- Secret Manager
    - Um serviço que guarda as senhas e credenciais de conexão com o banco de dados
    - Credenciais hardcoded não são uma boa ideia
- Padronização de logs
    - É a centralização dos logs em um único local
    - É um padrão único de print de logs, em ordem e informações
    - Criar uma biblioteca de logs para print de todo o sistema de maneira única
- Open Telemetry
    - É um meio do caminho para todas as vendors de visualização de dados e métricas, que padroniza para todas as tecnologias de APM
- Service Template
    - É a padronização de diversas tecnologias em SDKs, para que todo o projeto já esteja todo configurado antes do início
- Modelo C4
    - É uma linguagem de programação de documentação de arquitetura de software
    - C4: Context, Containers, Components and code 
    

    
